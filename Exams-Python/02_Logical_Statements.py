# Задание 2. Демонстрационное тестирование 2024, никаких гарантий, всё как есть. :)
# Автор: Alexander BitsCode. Лицензия: Creative Commons.
# Архив: https://www.youtube.com/@BitsCode/. Исходный код: https://github.com/dreamy-cat/Academic.

#  Задание 2. Логическая функция, соответствующая таблице и результату F.
#  Задание решается аналитически, карандашом, необходимо знать таблицы истинности для операторов:
# "И", "НЕ", "ИЛИ", "ИМПЛИКАЦИЯ или СЛЕДОВАТЕЛЬНО" и "РАВНЯЕТСЯ". Также соблюдать порядок действий 
# и рассматривать по частям или упрощать выражения, не забыть о симметричности команд.

print('    Задание 2. Демонстрационное тестирование 2024, язык Python, никаких гарантий, всё как есть. ;)')
print('\nЗадание решается аналитически, карандашом. Необходимо помнить таблицы логических операторов:')
print('A:\tB:\tНе:\tИ:\tИли:\tРавно:\tИмпликация:')
print('0', '0', int(not 0), int(0 and 0), int(0 or 0), int(0 == 0), int(0 <= 0), sep='\t')
print('0', '1', int(not 0), int(0 and 1), int(0 or 1), int(0 == 1), int(0 <= 1), sep='\t')
print('1', '0', int(not 1), int(1 and 0), int(1 or 0), int(1 == 0), int(1 <= 0), sep='\t')
print('1', '1', int(not 1), int(1 and 1), int(1 or 1), int(1 == 1), int(1 <= 1), sep='\t')

print('\nДана таблица истинности логической функции F: (X или Y) или (Y равняется Z) или (не W)')
print('?', '?', '?', '?', 'F', sep='\t')
print('-', '-', '0', '0', '0', sep='\t')
print('1', '0', '-', '0', '0', sep='\t')
print('1', '0', '1', '-', '0', sep='\t')

print('\n    Решение карандашом, сразу проходимся по скобкам и порядку вычисления. '
      'Выражение состоит из скобок и т.к. результат функции всегда 0, следовательно '
      'результат в каждом из выражений должен быть обязательно 0. '
      'Последнее выражение с "Не W", всегда должно быть 1, иначе результат функции будет 1, '
      'из всех столбцов таблицы, подходит только первый, т.е. первый столбец это W. '
      'Вторая скобка, операнды должны не быть равными, это возможно только для второго и третьего '
      'столбца и методом исключения определим X как четвертый столбец. Если X четвертый, то первая '
      'скобка исключет единицу, только если Y будет 3-им, т.к. последняя комбинация "- and 1" может дать '
      'единицу. Оставшаяся буква, это Z - второй столбец. Ответ: "WZYX".')

print('\nРешение через обработку всех вариантов значений сразу, буквы W, X, Y, Z - 0..3, строки могут повторятся, '
      'выбор ответа вручную, см. следующее решение, при определении копий строк.')
tabSizeV = 3; tabSizeH = 5; tabFuncR = 4
print('Общее количество перестановок для параметров', tabFuncR, 'факториал, комбинаций, строки повторяются!')
tabDef = [[-1, -1, 0, 0, 0], [1, 0, -1, 0, 0], [1, 0, 1, -1, 0]]
print('Исходная таблица(-1 если не определено), размеры [', tabSizeH, ', ', tabSizeV, ']: ', tabDef, sep='')
comb = [0, 0, 0, 0]; combAll = []; combCount = 1; combMax = 0x100; uniqCount = 0
# Основной цикл перебора, всех комбинаций.
while (combCount < combMax):
    isUniq = True; i = 0
    while ((isUniq == True) and (i < tabFuncR)):
        j = 0
        while ((isUniq == True) and (j < tabFuncR)):
            if ((i != j) and (comb[i] == comb[j])):
                isUniq = False
            j += 1
        i += 1
    if (isUniq == True):
        uniqCount += 1
        print('\nУникальная комбинация букв(цифр) определена:', comb)
        # Для отладки можно использовать индексы таблиц 0xCAA, 0xCAB - сразу подойдут или нет.
        tabIdx = 0x000; tabMax = 0x01 << (tabSizeV * tabFuncR); tabsCorrect = 0
        print('Перебираем', tabMax, 'возможных вариантов таблиц, подходящих для заданной таблицы.')
        # Или сформировать список иным способом, по размерам, двумерным или просто линейно.
        workTab = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
        while (tabIdx < tabMax):
            isCorrect = True; i = 0; bits = tabSizeV * tabFuncR; mask = 0x001 << (bits - 0x01)
            # Вычисление битовой комбинации, вывод закоментирован, не корректные таблицы пропускаются.
            #tabIdx = 0xCAB
            while (i < bits):
                bit = (tabIdx & mask) >> (bits - i - 1)
                # При "двумерном" списке или можно линейно, workTab[i].
                workTab[i // tabFuncR][i % tabFuncR] = bit
                i += 1
                mask >>= 0x01
            tabIdx += 1
            # Если вывод полный, то лучше отобразить только корректные.
            # print('\nТаблица для проверки:', workTab[0], workTab[1], workTab[2], sep='\n', end=' - ')
            i = 0; isCorrect = True
            while (i < tabSizeV and isCorrect == True):
                j = 0
                while (j < tabFuncR and isCorrect == True):
                    if (tabDef[i][j] != -1 and workTab[i][j] != tabDef[i][j]):
                        isCorrect = False
                    j += 1
                i += 1
            if (isCorrect):
                tabsCorrect += 1
                # Если удобней проверять вывод по строчкам, как в задании, то можно вывести следующей строчкой.
                #print('Таблица для проверки:', workTab[0], workTab[1], workTab[2], sep='\n', end=' - ')
                print('Таблица для проверки:', workTab, 'корректна', end=' ')
                #print('корректна', end=' ')
                i = 0; isFuncTrue = True
                while (i < tabSizeV and isCorrect):
                    # Позиции для удобства, но если пример простой, а комбинации все перебираются, то можно рискнуть и прямо так.
                    posW = comb.index(0); posX = comb.index(1); posY = comb.index(2); posZ = comb.index(3)
                    r1 = bool(workTab[i][posX] and (not workTab[i][posY]))
                    r2 = bool(workTab[i][posY] == workTab[i][posZ])
                    r3 = bool(not workTab[i][posW])
                    r = bool(r1 or r2 or r3)
                    if (r != tabDef[i][tabFuncR]):
                        isCorrect = False
                    i += 1
                if (isCorrect):
                    print('и все строки верны.')
                    combAll.extend(comb)
                    tabIdx = tabMax
                    # Закоментировано, если требуется выйти сразу при первом найденном, но мы смотрим все варианты.
                    # combCount = combMax
                else:
                    print('и строки неверны.')
            else:
                # Если вариантов очень много, то вывод о не корректности лучше опустить.
                #print('не корректна.')
                pass  
    # Следующая комбинация, путём увеличения индексов и проверки на переполнение, на Си сильно короче.
    j = 0; comb[j] += 1
    while ((j < tabFuncR) and (comb[j] == tabFuncR)):
        comb[j] = 0
        j += 1
        if (j < tabSizeH):
            comb[j] += 1
    combCount += 1
print('\nВсего уникальных комбинаций', uniqCount, 'последняя', comb)
print('Все комбинации по ответу. Верна та, где нет повторяющихся строк:', combAll, end='\n\n\n')

print('Вариант 2310401, номер 4 от 12-03-2024, от СтатГрада - очень странный.')
print('\nДана таблица истинности логической функции F, строчки не повторяются: ')
print('((X или Y) импл (Y и Z)) и ((W равно X) или (W импл не Z))')
print('?', '?', '?', '?', 'F', sep='\t')
print('1', '0', '-', '0', '1', sep='\t')
print('1', '0', '-', '0', '1', sep='\t')
print('1', '-', '-', '0', '1', sep='\t')

print('\n\tРешение карандашом, сразу проходимся по скобкам и порядку вычисления. Данное задание немного либо не точно, '
      'либо не уточнено условие. В пустых клетках могут быть как 0 так и 1, но комбинация считается корректной, '
      'если все комбинации удовлетворяют функции и условию, либо хотя бы одна комбинация верна. В данной задаче в последней '
      'строке одна из комбинаций приведет к неверному значению целевой функции.')
print('\tВыражение состоит из двух скобок с оператором "И" между ними, т.е. результат в 1 будет только если '
      'обе скобки будут обязательно по 1. В типе задания с уникальными(не повторяющимися) скобками '
      'стоит всегда проанализировать таблицу, и предположить примерное количество всех возможных комбинаций '
      'с учетом этого правила. В остальном аналогично предыдущему, биты функции также могут быть неоепределены.')
print('\tПо таблице можно заметить, что первые две строки практически равны кроме одного неопределенного бита '
      'в третьем столбце, следовательно комбинации (0-0) и (1-1) невозможны и остались только (0-1) и (1-0). '
      'В последней строке, во втором столбце, возможна только 1, т.к. если будет 0, то строка будет совпадать '
      'одной из предыдущих. Неопределенными остаются три бита 3-его столбца. Возможно: 101, 011, 100, 010.')
print('\tПо скобкам: первая и вторая скобка связаны тем, что если X или Y в единице, то для истины большой скобки '
      'необходимо, чтобы Y и Z были строго 1, следовательно Z возможна первым столбцом. Т.к. третья скобка не '
      'всегда будет совпадать, если строки не равны, то четвертая скобка должна быть истинна, отрицание от 1 это '
      'нули, это 4-ый столбец для W. Два столбца 2-ой и 3-ий распределим под X и Y. Т.к. если X будет 1, то '
      'и Y обязательно должен быть в 1. Распределение возможно только если X - второй, а Y - третий.\n')

print('\nДемонстрационный вариант, решение через обработку только допустимых вариантов и перестановок.')

# Таблица для демонстрационного варианта, demo WZYX 0321.
tabDef = [[-1, -1, 0, 0, 0], [1, 0, -1, 0, 0], [1, 0, 1, -1, 0]]
# Странный вариант от Статграда, 
#tabDef = [[1, 0, -1, 0, 1], [1, 0, -1, 0, 1], [1, -1, -1, 0, 1]]
# 15814 : YXZW : 2130 - еще несколько вариантов были для проверки.
#tabDef = [[1, -1, -1, 1, 0], [-1, -1, -1, 1, 0], [1, -1, 1, -1, 0]]
# 15939 : WZYX : 0321
#tabDef = [[-1, -1, -1, 1, 0], [1, -1, -1, 1, 0], [1, -1, 1, 1, 0]]
# 16805 : YXWZ : 2103
#tabDef = [[0, 0, -1, -1, 0], [0, -1, -1, 0, 0], [0, -1, 0, 0, 0]]
#18808 : YXWZ : 2103 - проверочный, условия прописаны.
#tabDef = [[-1, -1, -1, 1, 0], [1, -1, -1, -1, 0], [1, 1, -1, -1, 0]]

tabSizeV = 3; tabSizeH = 5; tabFuncR = 4
print('Исходная таблица(-1 если не определено), размеры [', tabSizeH, ', ', tabSizeV, ']: ', tabDef, sep='')
# Считаем количество неопределенных бит и их позиции в таблице.
i = 0; undefBits = 0; undefBitsPos = list()
while (i < tabSizeV):
    j = 0
    while (j < tabFuncR):
        if (tabDef[i][j] == -1):
            undefBitsPos.append([i, j])
            undefBits += 1
        j += 1
    i += 1
print('Количество неопределенных бит в таблице', undefBits, 'и их позици строка и столбец.', undefBitsPos)
comb = [0, 1, 2, 3]; combAll = []; combCount = 0; combMax = 24; uniqCount = 0
print('Уникальные комбинации и подстановка таблицы бит:')
# Основной цикл перебора вариантов таблицы.
while (combCount < combMax):
    uniqCount += 1
    print('\nКомбинация:', comb)
    j = 0
    while (j < (0x01 << undefBits)):
        k = 0; bits = []
        while (k < undefBits):
            bit = (j >> k) & 0x01
            bits.append(bit)
            # Подстановка только тех бит, которые не определены в таблице.
            tabDef[undefBitsPos[k][0]][undefBitsPos[k][1]] = bit
            k += 1
        print('Биты: ', bits, ' таблица: ', tabDef, sep='', end='')
        # Есть-ли одинаковые строки в таблице, если да, то пропускаем сразу этот вариант.
        k = 0; isUniq = True
        while (k < tabSizeV and isUniq):
            l = 0
            while (l < tabSizeV):
                if (k != l):
                    m = 0
                    while (m < tabFuncR and (tabDef[k][m] == tabDef[l][m])):
                        m += 1
                    if (m == tabFuncR):
                        isUniq = False
                l += 1
            k += 1
        if (isUniq):
            print(', строки уникальны: ', end='')
            k = 0; isFuncTrue = True
            while (k < tabSizeV):
                # Раскоментировать правила, если потребуется проверка других вариантов.
                posW = comb.index(0); posX = comb.index(1); posY = comb.index(2); posZ = comb.index(3)
                # Демонстрационный вариант.
                r1 = bool(tabDef[k][posX] and (not tabDef[k][posY]))
                r2 = bool(tabDef[k][posY] == tabDef[k][posZ])
                r3 = bool(not tabDef[k][posW])
                r = r1 or r2 or r3
                # Вариант СтатГрад.
                #r1 = bool((tabDef[k][posX] or tabDef[k][posY]) <= (tabDef[k][posY] and tabDef[k][posZ]))
                #r2 = bool((tabDef[k][posW]) == tabDef[k][posX])
                #r3 = bool(tabDef[k][posW] <= tabDef[k][posZ])
                #r = bool(r1 and (r2 or r3))
                # Вариант 18808.
                #r1 = bool(tabDef[k][posX] and not tabDef[k][posY])
                #r2 = bool(tabDef[k][posY] == tabDef[k][posZ])
                #r3 = bool(tabDef[k][posW])
                #r = bool(r1 or r2 or r3)
                print(r, sep='', end=' ')
                if (r != tabDef[k][tabFuncR]):
                    isFuncTrue = False
                k += 1
            if (isFuncTrue):
                print('- параметры найдены!')
                combAll += comb
            else:
                print('- не функция.')
        else:
            print(', есть повторяющиеся строки.')
        j += 1    
    # Итерационный алгоритм перестановок, ссылка на статью, для отладки можно выводить параметры.
    j = tabFuncR - 2
    while (j != -1 and comb[j] >= comb[j + 1]):
        j -= 1
    if (j != -1):
        k = tabFuncR - 1
        while (comb[j] >= comb[k]):
            k -= 1
        swap = comb[j]; comb[j] = comb[k]; comb[k] = swap
        i = j + 1; k = tabFuncR - 1
        while (i < k):
            swap = comb[i]; comb[i] = comb[k]; comb[k] = swap
            i += 1; k -= 1
    combCount += 1 
print('\nВсего уникальных комбинаций', uniqCount, 'последняя', comb)
print('Все комбинации по ответу(должна быть одна):', combAll, end='\n\n\n')

#   Дополнительные задания карандашом, просто для обсуждения, таблицы на сайте.

#   №15814, выражение: (x == (w or y)) or ((w <= z) and (y <= w)), ответ XZWY.
# Две скобки, и одна из них если не нуль, то функция неверна.
# Первая скобка, Х не должен быть равен W и Y. Методом исключения Х - толкьо второй, иначе одна из единиц совпадет.
# Вторая скобка не может быть только в обе единицы, остальные варианты приемлимы.
# Перебираем буквально WXZY - сразу первая строка выпадает, перебираем YXZW - подходит или упирается в противоречие.

#   №16377, выражение: ((x <= y) == (y <= z)) and (y or w) = F(1), ответ XZWY.
# Общие скобки в 1-цу возможны только если обе скобки равны 1, иначе значения не имеет.
# Т.к. по исходным данным у нас первые три строки много нулей, то по одной единице на строчке быть должно.
# Следовательно, в третьей столбце обязательно должна быть 1-ца на второй строке, тогда это W, Y - 2 или 4-ый.
# Второй столбец исключаем, т.к. выражение Y <= Z будет уже не сходящимся. Остается X и Y.
# С учетом Y <= Z и с подстановкой 1-ы, получаем что второй столбец только Z, а первый X - XZWY или при переборе.

#   №17366, выражение: ((x and w) or (w and z)) == ((z <= y) and (y < x)) = F(1), ответ YZWX.
# Скобки слева и справа могут быть равны, только если обе совпадают.
# Анализ таблицы, с учетом не повторяющихся вариантов, возможны только две комбинации 0-1 и 1-0 в третьем столбце.
# Задание на редкость неудобное, зацепится и явно что-то кроме перебора допустимых вариантов придумать сложновато.
# Можно немного предполагать. В левой части оператор или, в правой И. Т.к. Z всегда должно попадать как меньше или равно,
# то предположительно это второй столбец. Далее, столбцы 3 и 4 различны по набору, а первый всегда 1. Т.к. Z у нас предп.
# 0, то 1 в первой скобке, возможно только при X и W в 3 или 4-ом столбце. Остается только суровый перебор.

#   №19051, выражение: (x and not y) or (x == z) or not w = F(0), ответ XWZY.
# Анализ выражения, для того чтобы всё выражение было 0, необходимо чтобы каждый из слагаемых был 0.
# Анализ таблицы, условием различности строк. Сразу, т.к. последнее выражение not w, следовательно
# единственный возможный столбец для W - это второй, т.к. там могут быть одни единицы.
# Вторая скобка является нулем, только если переменные не равны, а это возможны 1 или 3-ый столбец
# для X или Z, т.к. для 3-ого и 4-ого будут равны.
# Если четвертый столбец остается для Y, то пробуем ZWXY - не подходит сразу, следовательно ответ XWZY. 

# №55619, выражения: F1 = (x or not y) == (z <= w); F2 = (not x == y) and (z <= w).
# Две логические функции. Таблица частично заполнена, с неповторяющимися строками.
# Вторая функция верна, только когда во второй строке две скобки будут 1 и результат 1.
# Это работает, только если 3-ий пустой - единица и это X или Y, обе функции сходятся при Y.
# Первая строка, первая функция 0, только если подставить в первый столбец 0, т.е. X.
# Оставшиеся W и Z при условии <=, возможно только ZWYZ.
