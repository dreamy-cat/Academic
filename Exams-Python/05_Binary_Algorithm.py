# Задание 5. Демонстрационное тестирование 2024, никаких гарантий, всё как есть! :)
# Автор: Alexander BitsCode. Лицензия: Creative Commons.
# Архив: https://www.youtube.com/@BitsCode/. Исходный код: https://github.com/dreamy-cat/Academic.

#   Задание решается карандашом если удобней, но и кодом тоже быстро, используя строки или битовые команды.
# Практически во всех случаях используются двоичное представление параметров, иногда может встретиться троичная.
#   Главное это внимательность и помнить, что обычно алгоритм по условию "сходится" к одному результату, 
# который может быть не первым по параметру. Правила преобразований, как правило, также однозначно определяются
# зная параметры результата, но не гарантированно. Также полезным могут быть критерии делимости.

print('    Задание 5. Демонстрационное тестирование 2024, никаких гарантий, всё как есть! :)\n')
print('    На вход алгоритма подается натуральное число N. Алгоритм строит по нему новое число R следующим образом.')
print('        1. Строится двоичная запись числа N.')
print('        2. Далее эта запись обрабатывается по следующими правилами:')
print('            а) если число N делится на 3, то к этой записи дописываются три последние двоичные цифры;')
print('            б) если число N не делится на 3, то остаток от деления умножается на 3, переводится в двоичную '
      'запись и дописывается в конец числа.')
print('    Полученная таким образом запись является двоичной записью, искомого числа R.')
print('    3. Результат переводится в десятичную систему счисления и выводится на экран.')
print('    Например, для исходного числа 12 = 1100[2], результатом является число 1100100[2] = 100, а '
      'для исходного числа 4 = 100[2], это число 10011[2] = 19.')
print('    Укажите минимальное число R большее 151, которое может быть получено с помощью описанного алгоритма. '
      'В ответе запишите это число в десятичной системе счисления.\n')
# Решение карандашом, со вспомогательной таблицей ниже, оценка интервала ответа применима и для решения перебором.
print('    Решение карандашом удобней, т.к. правила достаточно простые и все числа в пределах 8-ми бит.')
print('    Сначала проанализируем общие допустимые пределы вычислений насколько это возможно. '
      'Алгоритм только исполняет арифметическое смещение влево на 2 или 3 бита, в зависимости от условий, следовательно '
      'диапазоны итоговых чисел относительно условия могут быть (128, 256). Для смещения в 3 бита это 16 и 32 для 2-ух бит. '
      'Верхний предел 256, или 2 в 8-ой степени. Значит перебирать есть смысл до 64 при смещении 2-ух бит и '
      'до 32 при смещении 3-ех бит. Т.е. перебор можно предположительно реализовать от 16 до 64 включительно.')
print('    Дальше решать может быть удобней от обратного, от результата. По условию минимальный ответ удовлетворяющий '
      'условию 152, двоичное представление 10011000. Перебираем шаги алгоритма в обратном порядке и ищем первый параметр, '
      'с которым не будет противоречий по правилам задания. Дополнительно всмпомнить критерий делимости на 3.')
print('    152 - последние 3 бита равны 0 первое правило не применимо, т.к. биты не равны [000] и [011]. Второе '
      'правило иcключаем, т.к. возможно только окончание на 3 * 1 [11] или 3 * 2 [110]. Исключаем этот вариант.')
print('    10011[011] - первое число подходящее под второе правило, но не под первое т.к. 19 на три не делится. '
      'Если остаток от деления 100110(38) mod 3 = 2, то последние три бита должны быть 3 * 2 = 6[110], не совпадает с [011]. '
      'Аналогично 10011[110] - только второе правило, т.к. 19 не делится 3, остаток от деления 1, следовательно '
      'добавленные биты должны быть 3 * 1 = 3[011] а не [110] как в числе, оба варианта 155 и 158 исключаем.')
print('    Далее подобным образом движемся по числам, подставляя только эти три комбинации по возрастанию. '
      '159 - делится на три, но сразу видно что биты [011] и [111] не совпадают. Или 100111 - следующая комбинация (+1) '
      'относительно предыдущей, 10011, с учетом остатка, 100111[11] - уже проверили, 159.')
print('    Следующий 20(10100) остаток от деления 2, следовательно только второе правило, 10100[110] - 166, подходит и '
      'откладываем это число, возможно оно и есть результат, но т.к. у нас еще есть биты меньше [110] то посмотрим еще.')
print('    Чтобы результат алгоритма был меньше, необходимо чтобы она оканчивалась менее [110]. Для первого '
      'правила это невозможно, т.к. [100] в первой части уже меньше результат не даст, [101] и [101] при 21 '
      'исходной левой части. Следовательно остается только [011] - а это возможно только при остатке от деления 1 и '
      'следующем 101000(40), итоговое число 101000[11] и это 163. Т.к. при дальнейшем росте чисел и комбинаций '
      'результат алгоритма меньше не возможен, то анализ можно завершить.')
# Вспомогательная таблица от обратного результата R и все возможные варианты применения правил.
r = 151; rMax = 170; n = 0
print('\nВспомогательная таблица для аналитического решения, ')
print('R:\tRb:\t\tN:\tN1b:\tN2b:')
while (r < rMax):
      r += 1
      print(r, bin(r)[2:], sep='\t', end='\t')
      if ((r >> 0x03) % 3 == 0):
            n = r >> 0x03; mask = 0x07
            print(n, '{:05b}'.format(n), '{:03b}'.format(r & mask), 'делится на 3 без остатка.', sep='\t')
      elif ((r & 0x07) == 6):
            n = r >> 0x03; mask = 0x07
            print(n, '{:05b}'.format(n), '{:03b}'.format(r & mask), 'остаток от деления на 2.', sep='\t')
      elif ((r & 0x07) == 3):
            n = r >> 0x02; mask = 0x03
            print(n, '{:05b}'.format(n), '{:03b}'.format(r & mask), 'остаток от деления на 1.', sep='\t')
      else:
            print('не является числом подходящим под правила.')
# Пример работы с числами по битам, применение маски, объединение и смещений битов влево и вправо.
print('\n\nПримеры битовых операторов по аналогии с командами процессора:')
print('A1:\t\tAnd:\t\tA3:\t\tOr:\t\tA5:\t\tSHL3:\t\tSHR3:')
a1 = 0xFF; a2 = 0xC3; a3 = a1 & a2; a4 = 0x18; a5 = a3 | a4; a6 = a5 << 0x03; a7 = a5 >> 0x03
print('{:08b}'.format(a1), '{:08b}'.format(a2), '{:08b}'.format(a3), '{:08b}'.format(a4),
      '{:08b}'.format(a5), '{:08b}'.format(a6), '{:08b}'.format(a7), sep='\t')
a1 = 0xFF; a2 = 0x3C; a3 = a1 & a2; a4 = 0x81; a5 = a3 | a4; a6 = a5 << 0x03; a7 = a5 >> 0x03
print('{:08b}'.format(a1), '{:08b}'.format(a2), '{:08b}'.format(a3), '{:08b}'.format(a4),
      '{:08b}'.format(a5), '{:08b}'.format(a6), '{:08b}'.format(a7), sep='\t')
print('\nВ данном пример объединения старших разрядов нет, но если есть, то не забыть функции '
      '"bit_length" и "bit_count".')
print('Пример число 0xAB[', bin(0xAB)[2:], '], длина в битах ', 0xAB.bit_length(),
      ' и количество единиц ', 0xAB.bit_count(), sep='', end='.\n')
# Решение прямым перебором, минимальный сохраняется только один, списка нет.
print('\nРешение прямым перебором с применением смещения, маски и объединения бит.')
print('Число N и его двоичная форма, маска, число R и его первая часть 5-6 бит о ставшаяся часть 2-3 бита, '
      'минимальное значение R и тип правила.')
print('N:\tNb:\tMask:\tR:\tR1b:\tR2b:\tRmin:\tType:')
n = 0x10; nMax = (0x01 << 0x03) * (0x01 << 0x03); rMin = 0x100
while (n < nMax):
      if (n % 3 == 0):
            # Вычисление по первому правилу значения R, но более понятно будет пошаговое вычисление.
            # r = (n << 0x03) | (n & 0x07)
            bits = 0x03; mask = 0x00; i = 0
            while (i < bits):
                  mask = (mask << 0x01) | 0x01
                  i += 1
            r = (n << bits) | (n & mask)
            print(n, '{:06b}'.format(n), '{:03b}'.format(mask), r, '{:06b}'.format(r >> bits),
                  '{:03b}'.format(r & mask), rMin, 'первое правило, число делится на 3 без остатка.', sep='\t')
      else:
            # Вычисление по второму правилу значения R, но также пошагово.
            # r = (n << (n % 3) + 0x01) | ((n % 3) * 3)
            bits = (n % 3) + 0x01
            # Для разнообразия, кода, если масок немного то можно и условием или битовой командой, по вкусу.
            if (bits == 2):
                  mask = 0x03
            else:
                  mask = 0x07
            r = (n << bits) | ((bits - 1) * 3)
            print(n, '{:06b}'.format(n), '{:03b}'.format(mask), r, '{:06b}'.format(r >> bits),
                  '{:03b}'.format(r & mask), rMin, 'второе правило, число делится на 3 с остатком.', sep='\t')
      if (r > 151 and r < rMin):
            rMin = r
      n += 1
print('\nРезультат прямого перебора, минимальное значение R =', rMin, end='.\n\n')
# Решение обратным перебором, с учётом определенности правил и однозначности .
print('\nРешение обратным перебором с проверкой правил и выводом первого корректного.')
print('Решение может быть неопределенным, по правилам и получаемому значению, но в этом случае сработает. '
      'Параметры таблицы аналогичны предыдущим параметрам: N, R и его части.')
print('R:\tRb:\t\tR1b:\tR2b:\tN:\tType:')
r = 151; rMax = 175; isCorrect = False
while (r < rMax and not isCorrect):
      r += 1; bits = 0x00; mask = 0x00
      if ((r >> 0x03) % 3 == 0):
            # Сначала обрабатываем первое правило, биты нумеруются справа-налево и с нуля.
            bits = 0x03; mask = 0x07; n = r >> bits           
            print(r, '{:03b}'.format(r), '{:03b}'.format(r >> bits), '{:03b}'.format(r & mask), n,
                  'N делится на 3', sep='\t', end=', ')
            if ((r & mask) == ((r >> bits) & mask)):
                  print('биты [0, 2] и [3, 5] включительно, совпадают, корректно.')
                  isCorrect = True
            else:
                  print('биты [0, 2] и [3, 5] включительно, различаются.')
      elif ((r & 0x03) == 3 or (r & 0x07) == 6):
            # Второе правило, количество бит определяется через остаток от деления.
            mod = (n % 3); bits = mod + 1; n = r >> bits; i = 0; mask = 0x00
            while (i < bits):
                  mask = (mask << 0x01) | 0x01
                  i += 1
            print(r, '{:03b}'.format(r), '{:03b}'.format(r >> bits), '{:03b}'.format(r & mask), n,
                  'младшая часть равна %d' % mod, sep='\t', end=', ')
            if (n % 3 == mod):
                  print('совпадает с остатком деления (%d mod 3) * 3 = %d, корректно.' % (n, mod * 3))
                  isCorrect = True
            else:
                  print('различается с остатком деления (%d mod 3) * 3 = %d.' % (n, mod * 3))
      else:
            print(r, bin(r)[2:], '\t\t\tне подходит под оба правила.', sep='\t')
print('\nРезультат работы обратного перебора R =', r, end='.\n')
